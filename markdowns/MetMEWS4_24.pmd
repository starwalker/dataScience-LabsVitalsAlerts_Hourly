% Predicting Patient Risk of Meeting MEWS 4 Criteria In the Next 24 Hours.
% Austin Mishoe, Data Scientist, Medical University of South Carolina
% November 27th, 2018

```{python imports, echo=False, results=False}
import pickle
import pandas as pd
import numpy as np
from sklearn.metrics import f1_score,bidev_corrcoef
from multiprocessing import cpu_count
import pathos.pools as pp
num_cores = cpu_count()
import seaborn as sns
import matplotlib.pyplot as plt
import datetime
from prettytable import PrettyTable
pd.set_option('display.expand_frame_repr', False)
```

```{python data, echo=False}
data = pd.read_pickle('data/raw_data.p')
mgb = pickle.load(open('Hourly_Predictions_Bundle.p','rb'))
data['REPORTING_DATE'] = pd.to_datetime(data['REPORTING_TIME'].dt.strftime('%Y-%m-%d'))
data['REPORTING_WEEK'] = list(map(lambda x: x.isocalendar()[1],data['REPORTING_DATE']))


key_col = 'PAT_ENC_CSN_ID'
time_col = 'REPORTING_TIME'
date_col = 'REPORTING_DATE'
date_type = 'Day'
# target_cols = ['MetSIRS4_4hr_8', 'MetSIRS4_4hr_24','MetSIRS4_4hr_48', 'MetMEWS4_8', 'MetMEWS4_24','MetMEWS4_48']
# pred_cols = ['MetSIRS4_4hr_8_preds', 'MetSIRS4_4hr_24_preds', 'MetSIRS4_4hr_48_preds', 'MetMEWS4_8_preds', 'MetMEWS4_24_preds', 'MetMEWS4_48_preds']
target_cols = ['MetMEWS4']
pred_cols = ['MetMEWS4_24_preds']
sim_start_date = datetime.datetime(2018,5,1)
sim_end_date = datetime.datetime(2018,7,31)
target_col = target_cols[0]
pred_col = pred_cols[0]

# #['U4PC PEDIATRIC CARDIOVASCULAR ICU','C8PI PEDIATRIC ICU','A4CV CVICU','U4ST SURGICAL TRAUMA ICU','C8NN NEONATAL ICU', 'U6MI MICU', 'A3MS MSICU', 'U8NI NEURO SCIENCE ICU', 'U9NI 9TH FL NEURO ICU']
icu_depts = [dept for dept in data['DepartmentName'].unique() if dept !=None and dept.lower().__contains__('icu')]


## apply any filtering, in this case we already have the adult population -- we want to now filter out all icu hours
# icu_times = np.where(data['DepartmentName'].isin(icu_depts))[0]
# print('The percentage of ICU patient hours '+str(len(icu_times)/data.shape[0]))
# data = data.iloc[np.where(data['DepartmentName'].isin(icu_depts)==False)[0],:].reset_index(drop=True)
```


## Introduction
Modified Early Warning System(MEWS) is a numeric representation(score) comprised of five physiological parameters of the
patient’s vital signs (heart rate, respiratory rate, systolic blood pressure, temperature, and consciousness level).
Identifying patients at risk for deterioration and cardiopulmonary arrest and providing early
intervention can reduce unplanned admissions to the intensive care unit (ICU), in-patient cardiac arrests, and deaths.
(Source: https://www.americannursetoday.com/improving-patient-safety-modified-early-warning-scoring-system/)
MEWS criteria is listed below:

##### <u>Patient MEWS Scoring System</u>


  <ul style="margin-left: 20px;">
    <li>Body Temperature MEWS Score
      <ul>
        <li>2 if Temperature &lt;= 35°C (95°F)</li>
        <li>1 if Temperature &gt; 35°C (95°F) or &lt;= 36°C (96.8°F)</li>
        <li>0 if Temperature &gt; 36°C (96.8°F) or &lt;= 38°C (100.4°F)</li>
        <li>1 if Temperature &gt; 38°C (100.4°F) or &lt;= 38.6°C (101.48°F)</li>
        <li>2 if Temperature &gt; 38.6°C (101.48°F)</li>
      </ul>
    </li>
    <li>Heart Rate MEWS Score
      <ul>
        <li>2 if HR &lt;= 40</li>
        <li>1 if HR &gt; 40 or &lt;= 50</li>
        <li>0 if HR &gt; 50 or &lt;= 100</li>
        <li>1 if HR &gt; 100 or &lt;= 110</li>
        <li>2 if HR &gt; 110 or &lt;= 129</li>
        <li>3 if HR &gt; 29</li>
      </ul>
    </li>
    <li>Blood Pressure MEWS Score
      <ul>
        <li>3 if BP &lt;= 70</li>
        <li>2 if BP &gt; 70 or &lt;= 80</li>
        <li>1 if BP &gt; 80 or &lt;= 100</li>
        <li>0 if BP &gt; 100 or &lt;= 199</li>
        <li>2 if BP &gt; 199</li>
      </ul>
    </li>
    <li>Respiritory Rate MEWS Score
      <ul>
        <li>2 if RR &lt;= 8</li>
        <li>0 if RR &gt; 8 or &lt;= 14</li>
        <li>1 if RR &gt; 14 or &lt;= 20</li>
        <li>2 if RR &gt; 20 or &lt;= 29</li>
        <li>3 if RR &gt; 29</li>
      </ul>
    </li>
    <li>Alert, Voice, Pain, Unresponsive(AVPU) MEWS Score
      <ul>
        <li>0 if AVPU 'Alert'</li>
        <li>1 if AVPU 'Responsive to Voice'</li>
        <li>2 if AVPU 'Responsive to Pain'</li>
        <li>3 if AVPU 'Unresponsive</li>
      </ul>
    </li>
  </ul>

## Objective to Predict Probability of Adult Patient at MUSC Meeting MEWS 4 Criteria In The Next 24 Hours.
The objective of this model is to flag patients who will meet MEWS4 criteria in a 4hour window within 24
hours. This model will generate predictions <b>hourly</b> for all inpatients at MUSC.


## Variables Considered
The training data for the model was developed from the MUSC 'Hourly Labs and Vitals' pipeline which contains approximately
75 labs and vitals information for each inpatient at MUSC. The labs and vitals used in this study were chosen based on
frequency of occurrence. This dataset is grained at the patient-hour for all patients in the hospital.
The following list of variables were used to build the model. Please refer to the model markdown for more information
on model performance and the actual features that were used in the model.



### Results Table for MEWS4 Adults Per Day

The following table breaks down the number of actual MEWS4 patients at MUSC per day.
These numbers were calculated by looking at historic data between May 1, 2018 to July 31, 2018. Each time interval has a 90% CI, 5% lowerbound and 95% upperbound,
 and median number of patients with MEWS4 historically.


```{python targets_df, echo=False, evaluate=True, width=850}

targets_per_date_df = pd.DataFrame(np.zeros((len(target_cols),6)),index=[target_cols])
# iterate through each of the dates and find the number of unique pat_id's with each of the model alerts
#tmp_df has dimension of (num_dates,num_models) to keep track of how many unique patients were alerted on each of the date
date_cols = ['REPORTING_DATE','REPORTING_WEEK']
for date_col_ind in range(len(date_cols)):
    date_col = date_cols[date_col_ind]
    calculation_df = np.zeros((len(data[date_col].unique()),len(target_cols)))
    all_dates = data[date_col].unique()
    for date_ind in range(len(all_dates)):
        date = all_dates[date_ind]
        tmp_data = data.iloc[np.where(data[date_col]==date)[0],:].reset_index(drop=True)
        for target_ind in range(len(target_cols)):
            target_col = target_cols[target_ind]
            calculation_df[date_ind,target_ind] = len(np.unique(tmp_data[key_col][np.where(tmp_data[target_col]==1)[0]]))
    for target_ind in range(len(target_cols)):
        target_col = target_cols[target_ind]
        targets_per_date_df.iloc[0,(date_col_ind*3):((date_col_ind+1)*3)] = np.percentile(calculation_df[:,target_ind],np.array([5,50,95]))

cols = ['Day'+' '+percent for percent in [' 5%',' 50%',' 95%']]
cols.extend(['Week'+' '+percent for percent in [' 5%',' 50%',' 95%']])
targets_per_date_df.columns = cols

targets_per_date_df.style.apply(lambda x: ['' for i in x], axis=1)
```


### Determining the Optimal Cutoff for Alerts
The optimal cutoff is typically found by either doing cost analysis(if the cost of intervention is known) or by using an
evaluation metric to balance the Sensitivity vs. Specificity. Our team was not given the cost of False Positives/False
negatives or the amount of departmental resources that can be allocated, so we have rendered a table to display the results
 of using various cutoff values.

```{python opt cutoff, echo=False, evaluate=True, width=850}
# optimal_f1_dict  = {}
# optimal_mcc_dict = {}
#
# p = pp.ProcessPool(num_cores)
# # cutoffs = np.arange(90,100,1)
cutoffs = np.round(np.arange(.01,.08,.01),2)
# for target_ind in range(len(target_cols)):
#     pred_col = pred_cols[target_ind]
#     target_col = target_cols[target_ind]
#     print(target_col)
#     preds_binary_list = [1*(data[pred_col]>=cutoff).values for cutoff in cutoffs]
#     true_binary_list = [data[target_col].values for cutoff in cutoffs]
#     f1_scores = p.map(f1_score,true_binary_list,preds_binary_list)
#     mcc_scores = p.map(bidev_corrcoef, true_binary_list, preds_binary_list)
#     optimal_f1_dict[target_col]=cutoffs[f1_scores.index(max(f1_scores))]
#     optimal_mcc_dict[target_col] = cutoffs[mcc_scores.index(max(mcc_scores))]

# print('Optimal Cutoff using F1 Score: '+str(optimal_f1_dict[target_col]))
# print('Optimal Cutoff using MCC Score: '+str(optimal_mcc_dict[target_col]))
opt_cutoff=.03
```



### Alert Results By Cutoff
The following table shows the results of the model over various cutoff values on the entire MUSC inpatient population between
May 1, 2018 and July 31,2018. This data was part of the holdout dataset, i.e. during the training phase, the model never saw this data.
For the following analysis, all patients who met the MEWS4 criteria were identified and the
time of their first MEWS4 instance was calculated. Using this information, we calculated whether the model would have
alerted before, during/after, or entirely missed the patient using various cutoffs. The results over various cutoff values are shown below.
```{python alerts_results, echo=False, evaluate=True, width=850}
target_col = target_cols[target_ind]
pred_col = pred_cols[target_ind]
alert_results_table_columns = ['Total Patient Alerts Per '+date_type,'Non-ICU Patient Alerts Per '+date_type,'Proportion Alerts Prior','Proportion Alerts During/After','Proportion Alerts Missed','Average Alert Time Before Target(Hours)','Proportion Patient Wrong Alerts']
alert_results_table = pd.DataFrame(np.zeros((len(cutoffs),len(alert_results_table_columns))),columns=alert_results_table_columns,index=cutoffs)

alert_time_bins = pd.DataFrame(np.zeros((len(cutoffs),6)),columns=['>24 Hours','24-13 Hours','12-9 Hours','8-5 Hours','4-1 Hours','Alerted During/After'],index=cutoffs)
for cutoff in cutoffs:
    alerts_dict = {col: 0 for col in alert_results_table_columns}
    data['preds_binary']= 1*(data[pred_col]>=cutoff).values
    ppd_list = []
    nonicu_ppd_list = []
    for day in data['REPORTING_DATE'].unique():
        tmp_data = data.iloc[np.where(data['REPORTING_DATE']==day)[0],:].reset_index(drop=True)
        ppd_list.append(len(tmp_data.loc[np.where(tmp_data['preds_binary']==1)[0],'PAT_ENC_CSN_ID'].unique()))
        nonicu_ppd_list.append(len(tmp_data.loc[np.where((tmp_data['preds_binary']==1) & (tmp_data['DepartmentName'].isin(icu_depts)==False))[0],'PAT_ENC_CSN_ID'].unique()))
    alerts_dict['Total Patient Alerts Per '+date_type] = np.mean(ppd_list).round(2)
    alerts_dict['Non-ICU Patient Alerts Per ' + date_type] = np.mean(nonicu_ppd_list).round(2)
    unique_target_keys = data.loc[np.where(data['MetMEWS4']==1)[0],key_col].unique()
    unique_alert_keys = data.loc[np.where(data['preds_binary']==1)[0],key_col].unique()
    for target_key in unique_target_keys:
        first_target_time = min(data.loc[np.where((data[key_col]==target_key) & (data['MetMEWS4']==1))[0],time_col])
        alert_inds = np.where((data[key_col]==target_key) & (data['preds_binary']==1))[0]
        if len(alert_inds)==0:
            alerts_dict['Proportion Alerts Missed'] += 1
        else:
            first_alert_time = min(data.loc[alert_inds, time_col])
            alert_diff = (first_target_time.to_pydatetime() - first_alert_time.to_pydatetime()).total_seconds() / 3600
            if first_alert_time<first_target_time:
                alerts_dict['Proportion Alerts Prior']+=1
                if alert_diff<=4:
                    alert_time_bins.loc[cutoff, '4-1 Hours'] += 1
                elif alert_diff<=8:
                    alert_time_bins.loc[cutoff, '8-5 Hours'] += 1
                elif alert_diff<=12:
                    alert_time_bins.loc[cutoff, '12-9 Hours'] += 1
                elif alert_diff <= 24:
                    alert_time_bins.loc[cutoff, '24-13 Hours'] += 1
                else:
                    alert_time_bins.loc[cutoff, '>24 Hours'] += 1
            else:
                alerts_dict['Proportion Alerts During/After'] += 1
                alert_time_bins.loc[cutoff, 'Alerted During/After'] += 1

            alerts_dict['Average Alert Time Before Target(Hours)'] += alert_diff
    alerts_dict['Proportion Patient Wrong Alerts'] = len(
        (set(unique_alert_keys) - set(unique_alert_keys).intersection(unique_target_keys))) / len(unique_alert_keys)
    alerts_dict['Proportion Patient Wrong Alerts'] = len((set(unique_alert_keys) - set(unique_alert_keys).intersection(unique_target_keys)))/len(unique_alert_keys)
    for col in ['Proportion Alerts Missed','Proportion Alerts Prior','Proportion Alerts During/After','Average Alert Time Before Target(Hours)']:
        alert_results_table.loc[cutoff,col] = alerts_dict.get(col)/len(unique_target_keys)
    for col in ['Non-ICU Patient Alerts Per '+date_type,'Total Patient Alerts Per '+date_type,'Proportion Patient Wrong Alerts']:
        alert_results_table.loc[cutoff, col] = alerts_dict.get(col)



alert_time_bins = alert_time_bins/len(unique_target_keys)

alert_results_table = alert_results_table.round(2)
alert_results_table.style.apply(lambda x: ['background: lightgreen' if x.name == opt_cutoff else '' for i in x],
               axis=1)

```

### Breakdown of Alert Times for MEWS4 Patients
The following table further breaks down how many hours in advance this model would have fired for each of the MEWS4 patients by cutoff.
'Alerted During/After' is defined as the model either firing as soon as the patient met the MEWS4 criteria or after. The '4-1 Hours' column
gives the relative proportion of patients that would have been alerted on 1-4 hours prior to them meeting the MEWS4 criteria. Each of
the subsequent columns are defined similarly.

```{python alerts_time_results, echo=False, evaluate=True, width=850}
alert_time_bins = alert_time_bins.round(2)
alert_time_bins.style.apply(lambda x: ['background: lightgreen' if x.name == opt_cutoff else '' for i in x],
               axis=1)
```


### Top Non-ICU Departments By Number of Alerts Per Week
This table stratifies how the model will alert by department each week using the optimal cutoff. The first column, 'Number MetMEWS4_24 Patients Per Week',
gives the average number of MetMEWS4_24 patients in each department per week, the second gives the average number of patient's alerted
on each week, and the third column give the total number of unique patients that come through each department on a week by week basis.
The following departmental impact numbers were calculated using a cutoff value of 0.03.

```{python DepartmentalImpact, echo=False, evaluate=True, width=850}
opt_cutoff = 0.03
data[target_col+'_Alerts'] = list(map(lambda x: 1 if x> opt_cutoff else 0,data[pred_cols[0]]))
### these are the true number of individuals in each department with the flags
#agg_data_target = data[['DepartmentName','REPORTING_DATE',target_col, 'MetMEWS4']].groupby(['DepartmentName','REPORTING_DATE']).sum().groupby('DepartmentName').mean().sort_values(by=[target_col],ascending=False)
agg_data_target = data[['DepartmentName', 'REPORTING_DATE',target_col+'_24', target_col+'_Alerts', target_col]].groupby(
    ['DepartmentName', 'REPORTING_DATE']).sum().groupby('DepartmentName').mean().sort_values(by=[target_col],
                                                                                             ascending=False)
#agg_data_target = agg_data_target[:25]
agg_data_target['NumberUniquePatientsDaily'] = 0
for curr_dept in list(agg_data_target.index):
    agg_data_target.loc[curr_dept,'NumberUniquePatientsDaily'] = sum(1*data['DepartmentName']==curr_dept)/len(data['REPORTING_DATE'].unique())
#print(agg_data_target[:20])


depts = [dept for dept in agg_data_target.index if dept not in icu_depts][:15]
agg_data_df_cols = ['Number MetMEWS4_24 Patients Per Week','Number MetMEWS4_24 Alerts Per Week','Number Unique Patients Per Week By Dept']
agg_data_df = pd.DataFrame(np.zeros((len(depts),len(agg_data_df_cols))),columns=agg_data_df_cols,index=depts)
unique_weeks = data['REPORTING_WEEK'].unique()
for dept in depts:
    agg_dict ={col: 0 for col in agg_data_df_cols}
    for week in unique_weeks:
        agg_dict['Number MetMEWS4_24 Patients Per Week'] +=len(data.loc[np.where((data['DepartmentName']==dept)&(data['REPORTING_WEEK']==week)&(data[target_col]==1))[0],key_col].unique())
        agg_dict['Number MetMEWS4_24 Alerts Per Week'] += len(data.loc[np.where((data['DepartmentName']==dept)& (data['REPORTING_WEEK'] == week) & (data[target_col+'_Alerts'] == 1))[0], key_col].unique())
        agg_dict['Number Unique Patients Per Week By Dept']+=len(data.loc[np.where((data['DepartmentName']==dept)& (data['REPORTING_WEEK'] == week))[0], key_col].unique())
    for key in agg_dict.keys():
        agg_data_df.loc[dept,key] = agg_dict.get(key)/len(unique_weeks)


agg_data_df = agg_data_df.round(2).sort_values('Number MetMEWS4_24 Patients Per Week',ascending=False)
agg_data_df.style.apply(lambda x: ['' for i in x],axis=1)
```



### Concluding Remarks
<ol style="margin-left: 20px;">
  <li>A patient's risk score will be updated hourly. If any of their labs and vitals have changed, this will reflect in their subsequent risk score</li>
  <li>The cutoff used to trigger alerts can vary based on the number of resources at each department. This analysis was meant more to give a general overview of how the model performs on hour-to-hour basis for various departments, and the hospital as a whole.</li>
  <li>Our model is able to provide patient specific insight as to why a given person has a high/low risk score. With an alert, we seek to provide the top 10 features that are attributed to a patient's high prediction</li>
</ol>









